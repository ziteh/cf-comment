---
import './CfCommentBox.css';
---

<div id="cf-app"></div>

<script type="module">
  import DOMPurify from 'dompurify';
  import snarkdown from 'snarkdown';
  import { html, render } from 'lit-html';
  import { until } from 'lit-html/directives/until.js';
  import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';

  const API_URL = 'http://localhost:8787/api';
  const POST = '/blog/my-post';
  const ANONYMOUS = 'Anonymous';

  let currentReplyTo = null;
  let previewText = '';
  function renderMarkdown(md) {
    return unsafeHTML(DOMPurify.sanitize(snarkdown(md || '')));
  }
  function formatDate(timestamp) {
    const date = new Date(timestamp);

    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');

    let hour = date.getHours();
    const minute = String(date.getMinutes()).padStart(2, '0');
    const period = hour >= 12 ? 'PM' : 'AM';

    hour = hour % 12;
    if (hour === 0) hour = 12; // 0 => 12 AM or 12 PM
    const h = String(hour).padStart(2, '0');

    return `${y}/${m}/${d} ${h}:${minute} ${period}`;
  }

  function getDisplayName(comment) {
    return comment?.name || ANONYMOUS;
  }

  function setReplyTo(commentId) {
    currentReplyTo = commentId;
    renderApp();
  }

  function cancelReply() {
    currentReplyTo = null;
    renderApp();
  }

  function handleInputChange(e) {
    previewText = e.target.value;
    renderApp();
  }

  async function loadComments() {
    const res = await fetch(`${API_URL}/comments?post=${POST}`);
    return await res.json();
  }

  function createCommentItemTemplate(
    comment,
    isRoot = false,
    replyToName = null,
  ) {
    const className = isRoot ? 'comment' : 'reply';
    const headerClass = isRoot ? 'comment-header' : 'reply-header';
    const nameClass = isRoot ? 'comment-name' : 'reply-name';
    const timeClass = isRoot ? 'comment-time' : 'reply-time';
    const contentClass = isRoot ? 'comment-content' : 'reply-content';

    return html`
      <div class="${className}" ${isRoot ? `data-id="${comment.id}"` : ''}>
        <div class="${headerClass}">
          <span class="${nameClass}" title="${comment.id}"
            >${getDisplayName(comment)}</span
          >
          <span class="${timeClass}">${formatDate(comment.pubDate)}</span>
          ${replyToName
            ? html`<span class="reply-to"
                >回覆給
                <span title="${comment.replyTo}">${replyToName}</span></span
              >`
            : ''}
        </div>
        <div class="${contentClass}">${renderMarkdown(comment.msg)}</div>
        <button class="reply-button" @click=${() => setReplyTo(comment.id)}>
          回覆
        </button>
        ${isRoot ? html`<div class="replies"></div>` : ''}
      </div>
    `;
  }

  function createReplyTemplate(reply, commentMap) {
    const replyToComment = commentMap[reply.replyTo];
    const replyToName = replyToComment ? getDisplayName(replyToComment) : '';
    return createCommentItemTemplate(reply, false, replyToName);
  }

  function createCommentTemplate(rootComment, allReplies, commentMap) {
    const template = createCommentItemTemplate(rootComment, true);

    return html`
      <div class="comment" data-id="${rootComment.id}">
        <div class="comment-header">
          <span class="comment-name" title="${rootComment.id}"
            >${getDisplayName(rootComment)}</span
          >
          <span class="comment-time">${formatDate(rootComment.pubDate)}</span>
        </div>
        <div class="comment-content">${renderMarkdown(rootComment.msg)}</div>
        <button class="reply-button" @click=${() => setReplyTo(rootComment.id)}>
          回覆
        </button>
        <div class="replies">
          ${allReplies.map((reply) => createReplyTemplate(reply, commentMap))}
        </div>
      </div>
    `;
  }
  function processComments(data) {
    // no replyTo means it's a root comment
    const rootComments = data.filter((c) => !c.replyTo);

    const replyMap = {};
    data.forEach((comment) => {
      if (comment.replyTo) {
        if (!replyMap[comment.replyTo]) {
          replyMap[comment.replyTo] = [];
        }
        replyMap[comment.replyTo].push(comment);
      }
    });

    function getAllReplies(commentId) {
      const allReplies = [];
      const queue = [...(replyMap[commentId] || [])];

      while (queue.length > 0) {
        const reply = queue.shift();
        allReplies.push(reply);

        const childReplies = replyMap[reply.id] || [];
        queue.push(...childReplies);
      }

      return allReplies;
    }

    return rootComments.map((rootComment) => {
      const allReplies = getAllReplies(rootComment.id);
      return createCommentTemplate(rootComment, allReplies, commentMap);
    });
  }

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    await fetch(`${API_URL}/comments?post=${POST}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: formData.get('name'),
        msg: formData.get('message'),
        replyTo: currentReplyTo,
      }),
    });

    // reset the form and clear preview
    e.target.reset();
    previewText = '';
    currentReplyTo = null;

    // reload comments and re-render
    comments.length = 0; // clear comments cache
    renderApp();
  }

  function createFormTemplate() {
    return html`
      <form id="comment-form" @submit=${handleSubmit}>
        <input type="text" name="name" placeholder="姓名 (選填)" />
        <textarea
          name="message"
          placeholder="留言內容..."
          required
          @input=${handleInputChange}
        ></textarea>
        ${currentReplyTo
          ? html`<div id="reply-info">
              回覆給:
              <span id="reply-to-name"
                >${getDisplayName(commentMap[currentReplyTo])}</span
              >
              <button type="button" @click=${cancelReply}>取消回覆</button>
            </div>`
          : ''}

        <button type="submit">發送留言</button>
      </form>
      <div id="preview">
        ${previewText ? renderMarkdown(previewText) : html``}
      </div>
    `;
  }

  let commentMap = {};
  let comments = [];
  async function renderApp() {
    // loading comments
    if (comments.length === 0) {
      comments = await loadComments();
      commentMap = {};
      comments.forEach((comment) => {
        commentMap[comment.id] = comment;
      });
    }

    const appTemplate = html`
      <div class="cf-container">
        ${createFormTemplate()}
        <div id="comments">
          ${until(
            Promise.resolve(comments).then((data) => processComments(data)),
            html`<div>載入中...</div>`,
          )}
        </div>
      </div>
    `;

    render(appTemplate, document.getElementById('cf-app'));
  }

  // Initial render
  renderApp();
</script>
