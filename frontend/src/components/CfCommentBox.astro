---
import './CfCommentBox.css';
---

<div id="cf-app"></div>

<script type="module">
  import {
    html,
    render,
  } from 'https://cdn.jsdelivr.net/npm/lit-html@2.8.0/lit-html.min.js';
  import { until } from 'https://cdn.jsdelivr.net/npm/lit-html@2.8.0/directives/until.js';
  import { unsafeHTML } from 'https://cdn.jsdelivr.net/npm/lit-html@2.8.0/directives/unsafe-html.js';

  const API_URL = 'http://localhost:8787/api';
  const POST = '/blog/my-post';

  let currentReplyTo = null;
  let previewText = '';

  function renderMarkdown(md) {
    return unsafeHTML(DOMPurify.sanitize(snarkdown(md)));
  }

  function formatDate(timestamp) {
    const date = new Date(timestamp);

    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');

    let hour = date.getHours();
    const minute = String(date.getMinutes()).padStart(2, '0');
    const period = hour >= 12 ? 'PM' : 'AM';

    hour = hour % 12;
    if (hour === 0) hour = 12; // 0 => 12 AM or 12 PM
    const h = String(hour).padStart(2, '0');

    return `${y}/${m}/${d} ${h}:${minute} ${period}`;
  }

  function setReplyTo(commentId) {
    currentReplyTo = commentId;
    renderApp();
  }

  function cancelReply() {
    currentReplyTo = null;
    renderApp();
  }

  function handleInputChange(e) {
    previewText = e.target.value;
    renderApp();
  }

  async function loadComments() {
    const res = await fetch(`${API_URL}/comments?post=${POST}`);
    return await res.json();
  }

  function createReplyTemplate(reply, commentMap) {
    const replyToComment = commentMap[reply.replyTo];
    const replyToName = replyToComment
      ? replyToComment.name || 'Anonymous'
      : '';
    return html`
      <div class="reply">
        <div class="reply-header">
          <span class="reply-name" title="${reply.id}"
            >${reply.name || 'Anonymous'}</span
          >
          <span class="reply-time">${formatDate(reply.pubDate)}</span>
          ${replyToName
            ? html`<span class="reply-to"
                >回覆給
                <span title="${reply.replyTo}">${replyToName}</span></span
              >`
            : ''}
        </div>
        <div class="reply-content">${renderMarkdown(reply.msg || '')}</div>
        <button class="reply-button" @click=${() => setReplyTo(reply.id)}>
          回覆
        </button>
      </div>
    `;
  }

  function createCommentTemplate(rootComment, allReplies, commentMap) {
    return html`
      <div class="comment" data-id="${rootComment.id}">
        <div class="comment-header">
          <span class="comment-name" title="${rootComment.id}"
            >${rootComment.name || 'Anonymous'}</span
          >
          <span class="comment-time">${formatDate(rootComment.pubDate)}</span>
        </div>
        <div class="comment-content">
          ${renderMarkdown(rootComment.msg || '')}
        </div>
        <button class="reply-button" @click=${() => setReplyTo(rootComment.id)}>
          回覆
        </button>
        <div class="replies">
          ${allReplies.map((reply) => createReplyTemplate(reply, commentMap))}
        </div>
      </div>
    `;
  }

  function processComments(data) {
    // no replyTo means it's a root comment
    const rootComments = data.filter((c) => !c.replyTo);

    const commentMap = {};
    data.forEach((comment) => {
      commentMap[comment.id] = comment;
    });

    function getAllReplies(commentId) {
      // find all comments that reply to the given commentId
      const directReplies = data.filter((c) => c.replyTo === commentId);

      // find all replies for each direct reply
      const allReplies = [...directReplies];
      directReplies.forEach((reply) => {
        // find replies to the reply
        const subReplies = getAllReplies(reply.id);
        allReplies.push(...subReplies);
      });

      return allReplies;
    }

    return rootComments.map((rootComment) => {
      const allReplies = getAllReplies(rootComment.id);
      return createCommentTemplate(rootComment, allReplies, commentMap);
    });
  }

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    await fetch(`${API_URL}/comments?post=${POST}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: formData.get('name'),
        msg: formData.get('message'),
        replyTo: currentReplyTo,
      }),
    });

    // reset the form and clear preview
    e.target.reset();
    previewText = '';
    currentReplyTo = null;

    // reload comments and re-render
    comments.length = 0; // clear comments cache
    renderApp();
  }

  function createFormTemplate() {
    return html`
      <form id="comment-form" @submit=${handleSubmit}>
        <input type="text" name="name" placeholder="姓名 (選填)" />
        <textarea
          name="message"
          placeholder="留言內容..."
          required
          @input=${handleInputChange}
        ></textarea>
        ${currentReplyTo
          ? html`<div id="reply-info">
              回覆給:
              <span id="reply-to-name"
                >${commentMap[currentReplyTo]?.name || 'Anonymous'}</span
              >
              <button type="button" @click=${cancelReply}>取消回覆</button>
            </div>`
          : ''}
        <button type="submit">發送留言</button>
      </form>
      <div id="preview">
        ${previewText ? renderMarkdown(previewText) : html``}
      </div>
    `;
  }

  let commentMap = {};
  let comments = [];

  async function renderApp() {
    // loading comments
    if (comments.length === 0) {
      comments = await loadComments();
      comments.forEach((comment) => {
        commentMap[comment.id] = comment;
      });
    }

    const appTemplate = html`
      <div class="cf-container">
        ${createFormTemplate()}
        <div id="comments">
          ${until(
            Promise.resolve(comments).then((data) => processComments(data)),
            html`<div>載入中...</div>`,
          )}
        </div>
      </div>
    `;

    render(appTemplate, document.getElementById('cf-app'));
  }

  // Initial render
  renderApp();
</script>
