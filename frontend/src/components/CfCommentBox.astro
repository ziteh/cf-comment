---
import './CfCommentBox.css';
---

<div id="cf-app"></div>

<script type="module">
  import DOMPurify from 'dompurify';
  import snarkdown from 'snarkdown';
  import { html, render } from 'lit-html';
  import { until } from 'lit-html/directives/until.js';
  import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
  const API_URL = 'http://localhost:8787/api';
  const POST = '/blog/my-post';
  const ANONYMOUS = 'Anonymous';

  let currentReplyTo = null;
  let previewText = '';
  let editingComment = null;

  function saveCommentAuthInfo(data) {
    const authInfo = {
      id: data.id,
      timestamp: data.timestamp,
      token: data.token,
    };

    sessionStorage.setItem(`comment_${data.id}`, JSON.stringify(authInfo));
    return authInfo;
  }

  function getCommentAuthInfo(commentId) {
    const authInfoStr = sessionStorage.getItem(`comment_${commentId}`);
    return authInfoStr ? JSON.parse(authInfoStr) : null;
  }

  function canEditComment(commentId) {
    return !!getCommentAuthInfo(commentId);
  }

  function renderMarkdown(md) {
    return unsafeHTML(DOMPurify.sanitize(snarkdown(md || '')));
  }
  function formatDate(timestamp) {
    const date = new Date(timestamp);

    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');

    let hour = date.getHours();
    const minute = String(date.getMinutes()).padStart(2, '0');
    const period = hour >= 12 ? 'PM' : 'AM';

    hour = hour % 12;
    if (hour === 0) hour = 12; // 0 => 12 AM or 12 PM
    const h = String(hour).padStart(2, '0');

    return `${y}/${m}/${d} ${h}:${minute} ${period}`;
  }

  function getDisplayName(comment) {
    return comment?.name || ANONYMOUS;
  }

  function setReplyTo(commentId) {
    currentReplyTo = commentId;
    renderApp();
  }

  function cancelReply() {
    currentReplyTo = null;
    renderApp();
  }

  function handleInputChange(e) {
    previewText = e.target.value;
    renderApp();
  }

  async function loadComments() {
    const res = await fetch(`${API_URL}/comments?post=${POST}`);
    return await res.json();
  }
  function createCommentItemTemplate(
    comment,
    isRoot = false,
    replyToName = null,
    allReplies = null,
    commentMap = null,
  ) {
    const className = isRoot ? 'comment' : 'reply';
    const headerClass = isRoot ? 'comment-header' : 'reply-header';
    const nameClass = isRoot ? 'comment-name' : 'reply-name';
    const timeClass = isRoot ? 'comment-time' : 'reply-time';
    const contentClass = isRoot ? 'comment-content' : 'reply-content';
    const canEdit = canEditComment(comment.id);

    return html`
      <div class="${className}" ${isRoot ? `data-id="${comment.id}"` : ''}>
        <div class="${headerClass}">
          <span class="${nameClass}" title="${comment.id}"
            >${getDisplayName(comment)}</span
          >
          <span class="${timeClass}">${formatDate(comment.pubDate)}</span>
          ${replyToName
            ? html`<span class="reply-to"
                >回覆給
                <span title="${comment.replyTo}">${replyToName}</span></span
              >`
            : ''}
          ${canEdit
            ? html`<span class="comment-controls">
                <button class="edit-button" @click=${() => handleEdit(comment)}>
                  編輯
                </button>
                <button
                  class="delete-button"
                  @click=${() => handleDelete(comment.id)}
                >
                  刪除
                </button>
              </span>`
            : ''}
        </div>
        <div class="${contentClass}">${renderMarkdown(comment.msg)}</div>
        <button class="reply-button" @click=${() => setReplyTo(comment.id)}>
          回覆
        </button>
        ${isRoot && allReplies
          ? html`<div class="replies">
              ${allReplies.map((reply) => {
                const replyToComment = commentMap[reply.replyTo];
                const replyToName = replyToComment
                  ? getDisplayName(replyToComment)
                  : '';
                return createCommentItemTemplate(reply, false, replyToName);
              })}
            </div>`
          : isRoot
            ? html`<div class="replies"></div>`
            : ''}
      </div>
    `;
  }

  function createCommentTemplate(rootComment, allReplies, commentMap) {
    return createCommentItemTemplate(
      rootComment,
      true,
      null,
      allReplies,
      commentMap,
    );
  }

  function processComments(data) {
    // no replyTo means it's a root comment
    const rootComments = data.filter((c) => !c.replyTo);

    const replyMap = {};
    data.forEach((comment) => {
      if (comment.replyTo) {
        if (!replyMap[comment.replyTo]) {
          replyMap[comment.replyTo] = [];
        }
        replyMap[comment.replyTo].push(comment);
      }
    });

    function getAllReplies(commentId) {
      const allReplies = [];
      const queue = [...(replyMap[commentId] || [])];

      while (queue.length > 0) {
        const reply = queue.shift();
        allReplies.push(reply);

        const childReplies = replyMap[reply.id] || [];
        queue.push(...childReplies);
      }

      return allReplies;
    }

    return rootComments.map((rootComment) => {
      const allReplies = getAllReplies(rootComment.id);
      return createCommentTemplate(rootComment, allReplies, commentMap);
    });
  }
  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    if (editingComment) {
      const authInfo = getCommentAuthInfo(editingComment.id);
      if (!authInfo) {
        alert('無法編輯此評論，權限已過期');
        return;
      }

      const response = await fetch(`${API_URL}/comments?post=${POST}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: authInfo.id,
          timestamp: authInfo.timestamp,
          token: authInfo.token,
          name: formData.get('name'),
          msg: formData.get('message'),
        }),
      });

      if (response.ok) {
        e.target.reset();
        previewText = '';
        editingComment = null;
      } else {
        alert('編輯評論失敗，可能權限已過期');
      }
    } else {
      const response = await fetch(`${API_URL}/comments?post=${POST}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: formData.get('name'),
          msg: formData.get('message'),
          replyTo: currentReplyTo,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        saveCommentAuthInfo(data);

        e.target.reset();
        previewText = '';
        currentReplyTo = null;
      } else {
        alert('發送評論失敗');
      }
    }

    comments.length = 0;
    renderApp();
  }

  async function handleDelete(commentId) {
    if (!confirm('確定要刪除此評論嗎?')) return;

    const authInfo = getCommentAuthInfo(commentId);
    if (!authInfo) {
      alert('無法刪除此評論，權限已過期');
      return;
    }

    const response = await fetch(`${API_URL}/comments?post=${POST}`, {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        id: authInfo.id,
        timestamp: authInfo.timestamp,
        token: authInfo.token,
      }),
    });

    if (response.ok) {
      sessionStorage.removeItem(`comment_${commentId}`);

      comments.length = 0;
      renderApp();
    } else {
      alert('刪除評論失敗，可能權限已過期');
    }
  }

  function handleEdit(comment) {
    editingComment = comment;
    document.querySelector('#comment-form input[name="name"]').value =
      comment.name || '';
    document.querySelector('#comment-form textarea[name="message"]').value =
      comment.msg || '';
    previewText = comment.msg || '';
    document
      .querySelector('#comment-form')
      .scrollIntoView({ behavior: 'smooth' });
    renderApp();
  }

  function cancelEdit() {
    editingComment = null;
    document.querySelector('#comment-form').reset();
    previewText = '';
    renderApp();
  }
  function createFormTemplate() {
    return html`
      <form id="comment-form" @submit=${handleSubmit}>
        <input type="text" name="name" placeholder="姓名 (選填)" />
        <textarea
          name="message"
          placeholder="留言內容..."
          required
          @input=${handleInputChange}
        ></textarea>
        ${currentReplyTo
          ? html`<div id="reply-info">
              回覆給:
              <span id="reply-to-name"
                >${getDisplayName(commentMap[currentReplyTo])}</span
              >
              <button type="button" @click=${cancelReply}>取消回覆</button>
            </div>`
          : ''}
        ${editingComment
          ? html`<div id="edit-info">
              編輯中:
              <span id="edit-comment-id">${editingComment.id}</span>
              <button type="button" @click=${cancelEdit}>取消編輯</button>
            </div>`
          : ''}

        <button type="submit">
          ${editingComment ? '更新留言' : '發送留言'}
        </button>
      </form>
      <div id="preview">
        ${previewText ? renderMarkdown(previewText) : html``}
      </div>
    `;
  }

  let commentMap = {};
  let comments = [];
  async function renderApp() {
    // loading comments
    if (comments.length === 0) {
      comments = await loadComments();
      commentMap = {};
      comments.forEach((comment) => {
        commentMap[comment.id] = comment;
      });
    }

    const appTemplate = html`
      <div class="cf-container">
        ${createFormTemplate()}
        <div id="comments">
          ${until(
            Promise.resolve(comments).then((data) => processComments(data)),
            html`<div>載入中...</div>`,
          )}
        </div>
      </div>
    `;

    render(appTemplate, document.getElementById('cf-app'));
  }

  // Initial render
  renderApp();
</script>
